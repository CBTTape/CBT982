//CLARKE1 JOB (R777),'LONS 8TH',MSGCLASS=X,NOTIFY=CLARKE
//ASM EXEC PGM=ASMBLR,PARM='NODECK,OBJ,TERM,XREF(SHORT),LIST,TEST'
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=19040
//*        DD  DSN=SYS1.AMODGEN,DISP=SHR
//         DD  DSN=CLARKE.JOL60.MACLIB,DISP=SHR
//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(CYL,(2,2)),UNIT=SYSDA
//SYSUT2   DD  DSN=&&SYSUT2,SPACE=(CYL,(2,2)),UNIT=SYSDA
//SYSUT3   DD  DSN=&&SYSUT3,SPACE=(CYL,(2,2)),UNIT=SYSDA
//SYSGO DD DSN=CLARKE.JOL60.OBJ($JOLPC60),DISP=SHR
//SYSTERM  DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
         GBLC  &TYPE                                              J40B
&TYPE    SETC  'SCHED'                                            J40B
         GENSAVE CSECT=$JOLPC60
* THIS PROGRAM CONVERTS DATA HELD IN CHARACTER FORM TO THE JOL
*      MAINFRAME FORMAT.
*
* IT IS REQUIRED BECAUSE WE WISH TO TRANSMIT DATA FROM THE PC
*      TO THE MAINFRAME IN THE MOST ECONOMICAL FORMAT, AND IN
*      A FORMAT THAT MOST TRANSMISSION PROGRAMS CAN HANDLE.
*
*        L     R11,=A($JOLPC60)
*        USING $JOLPC60,R11
*        DROP  R13
         L     R5,=A(PGMDETS)
         USING  PGMDETS,R5
         L     R6,=A(DDDSNDET)
         USING  DDDSNDET,R6
         L     R7,=A(INST)
         USING  INST,R7
         L     R8,=A(RECAREA)
         USING  RECAREA,R8
         #PRINT 'JOLCP40 STARTED'
         OPEN  CARDSIN
         OPEN  SYSUT1
         OPEN  (SYSIN,OUTPUT)
         PUT   SYSIN,DATAHD          OUTPUT THE HEADER RECORD
         #PRINT 'FILES OPEN'
         ZAP   TOTRECOP,=P'0'
LOOPCRD  GET   CARDSIN,RECORD
*        #PRINT 'READ A REC$'
*        #PRINT RECORD
         CLC   =C'FF**FF**FF$$',RECORD   NEW CARD HEADER?         J40B
         BE    NEWCARDM                  YES, SO MAKE NEW HEADER  J40B
         PUT   SYSIN,RECORD              OUTPUT CARD IMAGE        J40B
         B     LOOPCRD                   GO GET ANOTHER CARD      J40B
NEWCARDM DS     0H
         MVC   DATAMEM,RECORD+10                                  J40B
         MVC   DATAMEM5,=CL5'800 '                                J40B
         MVC   DATAMEM6,=CL5'0080'                                J40B
         PUT   SYSIN,DATAMEM1
         B     LOOPCRD                   GO GET ANOTHER CARD      J40B
*
* END OF CARDS
*
EOCARDS  DS    0H
         CLOSE CARDSIN
LOOP     GET   SYSUT1,RECORD
*        #PRINT 'READ A REC'
GOTREC   DS     0H
*        #PRINT RECORD
         CLC   RECORD(2),=C'EOF;'                                 J40B
         BE    EOJ                                                J40B
* TEST RECORD  TYPE
         CLC   =C'I=',RECORD  IS THIS A JOL INSTRUCTION?
         BE    PC40INS
         CLC   =C'DD',RECORD  IS THIS A DDCARD TYPE RECORD ?
         BE    PC40DD
         CLC   =C'ERUN',RECORD  IS THIS A EXEC TYPE RECORD ?
         BE    PC40EXEC
         #PRINT 'JOLCP40:INVALID RECORD FOUND'
         B     LOOP
PC40INS  L     R15,=V(RTN40INS)
         BALR  R14,R15
         B     GOTREC
PC40DD   L     R15,=V(RTN40DDS)
         BALR  R14,R15
         B     GOTREC
PC40EXEC L     R15,=V(RTN40EXE)
         BALR  R14,R15
         B     GOTREC
EOJ      CLOSE  SYSUT1
         CLOSE  SYSIN
         MP    TOTRECOP,=P'80'
         UNPK  INSTSIZE,TOTRECOP
         OI    INSTSIZE+L'INSTSIZE-1,C'0'
         #PRINT 'ENDED PC SETUP'
         #PRINT 'JOL DYNAMIC SCHEDULER CALLED WITH:',#JOLPARM
         #PRINT ' '              CLEAR BUFFER
         LINK  EP=$JOLDY40,PARAM=#JOLPARM,VL=1                     J40B
         GENRETN RC=(15)
         LTORG
         GENSAVE CSECT=RTN40INS
*        #PRINT 'AT INS$'
         MVC   ILENGTH,=AL2(IBODY)
         CLEAR ITEXT
         CLEAR IDUMMY
         MVC   ILABEL,PCISTEP
         MVC   ISTMT,PCISTMT
         JOLCONV PCILEV
         STC   R1,ILEVEL
*        JOLCONV PCINEST
         STC   R1,INEST
         MVC   ICOMMAND,PCICMD
*        #PRINT 'ICMD='
*        #PRINT PCICMD
*        #PRINT 'PCILEN=',PCILEN
         LA    R1,0
         IFNULL PCILEN,SETILEN                                   J40B
         TNUM  PCILEN         SEE IF ANY TEXT FOR COMMAND
SETILEN  STH   R1,ITEXT       SET FIRST 2 BYTES TO LENGTH OF TEXT
* MOVE THE TXT  FROM PCITXT TO ITEXT+2 (256 BYTES WILL DO)
         MVC   ITEXT+2(255),PCITXT
         AH    R1,ILENGTH
         STH   R1,ILENGTH
         GET   SYSUT1,RECORD
         CLI   RECORD,C'*'   CONTINUED RECORD ?
         BNE   RT40INS0
RT40INS0 EQU   *
I40NOTXT EQU   *
*        #PRINT 'WRITING INS$'
         LA    R1,INST        ADDRESS OF RECORD TO WRITE
         L     R15,=V(OPJOLREC)
         BALR  R14,R15
         GENRETN
         LTORG
         GENSAVE CSECT=RTN40DDS
*        #PRINT 'AT DDS$'
         MVI   DDOSVB,C' '                                        J40B
         MVC   DDOSVB+1(DDLEN-1),DDOSVB                           J40B
         CLEAR DDSPECTP,DDSPECT2,DDCANCEL,                        75128*
               DDCANCEL,DDLABEL,DDUNITNO,DDPRIM,DDSEC,DDDIRECT,   80290*
               DDBLKSZE,DDLRECL,DDSIZE,DDSIZE2,DDAVREC,DDBUFNO,   80290*
               DDBUFND,DDBUFNI,                                   82300*
               DDBUFL,DDRKP,DDKEYLEN,DDOVERFL,DDVOLSEQ,DDMAXVOL,  80290*
               DDUNITQU,DDAEXTRA
         MVI   DDDD1,C'D'                      SET RECORD TYPE TO'D'
         MVC   DDOSVB(4),=AL2(DDLEN,0)
*        LA    R6,DDWORKAR                NOW WE WILL USE THE COPY
         MVC   DDSTMT,PCDSTMT
         MVC   DDDSID,PCDDSID
         JOLCONV PCDLEV
         STC   R1,DDLEVEL
         JOLCONV PCDNEST
         STC   R1,DDNEST
         JOLCONV PCDTYP
         STC   R1,DDTYPE
         MVC   DDDDNAME,PCDDDNAM
* START DISP(1)
         SR    R1,R1
         NC    PCDDISP1(8),=X'0101010101010101'
         IC    R15,PCDDISP1
         AR    R1,R15
         SLL   R1,1
         IC    R15,PCDDISP1+1
         AR    R1,R15
         SLL   R1,1
         IC    R15,PCDDISP1+2
         AR    R1,R15
         SLL   R1,1
         IC    R15,PCDDISP1+3
         AR    R1,R15
         SLL   R1,1
         IC    R15,PCDDISP1+4
         AR    R1,R15
         SLL   R1,1
         IC    R15,PCDDISP1+5
         AR    R1,R15
         SLL   R1,1
         IC    R15,PCDDISP1+6
         AR    R1,R15
         SLL   R1,1
         IC    R15,PCDDISP1+7
         AR    R1,R15
         STC   R1,DDUSE
* END DISP(1)
         MVC   DDDISP1(2),PCDDISP2
* END DISP
DD40GETN GET   SYSUT1,RECORD
         CLI   RECORD,C'*'   CONTINUED RECORD ?
         BNE   RT40DD0
         CLC   =C'*DSN=',RECORD
         BNE   DD40NDSN
* HANDLE DSNAME FIELD
         MVC   DDDSNAME,PCDDSN         THATS 44 CHARACTERS!
         CLI   PCDMEM1,C'('            MEMBER NAME?
         BNE   DD40NMEM
         MVC   DDMBR,PCDMEM            YES, MOVED
DD40NMEM CLI   PCDPASS1,C'/'            PASSWORD?
         BNE   DD40NPAS
         MVC   DDPASSW,PCDPASSW
DD40NPAS EQU   *
         CLC   =C'SYSOUT=',DDDSNAME                               J40B
         BNE   DD40GETN                GET NEXT RECORD
         MVC   DDSYSCLS,DDDSNAME+7     COPY SYSOUT CLASS          J40B
         MVC   DDSYSPGM,BLANKS                                    J40B
         MVC   DDSYSFRM,BLANKS                                    J40B
         CLEAR DDCOPIES                                           J40B
         CLEAR DDOUTLIM                                           J40B
*        CLEAR DDALIGN                                            J40B
*        CLEAR DDALIGN                                            J40B
         CLI   DDDSNAME,C'*'                                      J40B
         BNE   DD40GETN                GET NEXT RECORD
         MVI   DDDSNAME,C'X'                                      J40B
         B     DD40GETN                GET NEXT RECORD
         SPACE 2
DD40NDSN CLC   =C'*DCB=',RECORD
         BNE   DD40NDCB                NOT DCB
         MVC   DDRECFM,PCDRECFM
         JOLCONV PCDBLKS
         STH   R1,DDBLKSZE
         JOLCONV PCDLRECL
         STH   R1,DDLRECL
         CLC   PCDDENSX,BLANKS                                    J40B
         BE    DD40NDEN                                           J40B
         JOLCONV PCDDENSX
         STC   R1,DDDENS
DD40NDEN DS    0H
         JOLCONV PCDBUFNO
         STC   R1,DDBUFNO
         MVC   DDOPTCD,PCDOPTCD
         MVC   DDDSORG,PCDDSORG
         B     DD40GETN                GET NEXT RECORD
DD40NDCB CLC   =C'*UNIT=',RECORD
         BNE   DD40NUNI                NOT UNIT
         MVC   DDUNIT,PCDUNIT2
         CLI   PCDUNDUM,C','
         BNE   DD40NUCN
         MVC   DDUNITNO,PCDUNITC
         CLI   DDUNITNO,C'P'
         BNE   DD40NUCN
         JOLCONV PCDUNITC
         STC   R1,DDUNITNO
DD40NUCN EQU   *
         B     DD40GETN                GET NEXT RECORD
DD40NUNI CLC   =C'*SPACE=',RECORD
         BNE   DD40NSPC                NOT SPACE
         MVC   DDCYLTRK,PCDSPCTY
*        MVC   DDRLSE,PCDRLSE
         JOLCONV PCDPRIM
         STH   R1,DDPRIM
         JOLCONV PCDSEC
         STH   R1,DDSEC
         JOLCONV PCDDIR
         STH   R1,DDDIRECT
         B     DD40GETN                GET NEXT RECORD
DD40NSPC CLC   =C'*VOL=',RECORD
         BNE   DD40NVOL                NOT VOL
         JOLCONV PCDFILE
         STH   R1,DDLABEL
*        JOLCONV PCDDENS
*        STC   R1,DDDENS
         MVC   DDVOLUME,PCDVOL
         B     DD40GETN                GET NEXT RECORD
DD40NVOL #PRINT 'INVALID CONTINUATION RECORD'
         SPACE 2
RT40DD0  EQU    *
*        #PRINT 'WRITING DD$'
         LA    R1,DDDSNDET    ADDRESS OF RECORD TO WRITE
         L     R15,=V(OPJOLREC)
         BALR  R14,R15
*        L     R6,=A(DDDSNDET)         RESET RECORD TO USE CSECT
         GENRETN
         LTORG
         GENSAVE CSECT=RTN40EXE
*        #PRINT 'AT EXE$'
         MVI   PGMLABEL,C' '                                      J40B
         MVC   PGMLABEL+1(PGMLEN-7),PGMLABEL                      J40B
         MVC   #PGMDETS,=AL2(PGMLEN)                              J40B
         MVI   PGMTYPEI,C'E'                                      J40B
         MVC   PGMSTMT,PCESTMT                                    J40B
         MVC   PGMSTEP,PCESTEP                                    J40B
         MVC   PGM,PCEPGM                                         J40B
         MVC   PGMSTEP,PCELABEL                                   J40B
         GET   SYSUT1,RECORD
*        CLI   RECORD,C'*'   CONTINUED RECORD ?
*        BNE   RT40EXE0
*T40EXE0 GENRETN
         LA    R1,PGMDETS     ADDRESS OF RECORD TO WRITE
         L     R15,=V(OPJOLREC)
         BALR  R14,R15
         GENRETN
         LTORG
         GENSAVE CSECT=OPJOLREC
         LR    R10,R1
*        #PRINT 'AT OP$'
         MVC   DATAMEM,=CL8'$$INST'                               J40B
         MVC   DATAMEM5,=CL5'1000'                                J40B
         MVC   DATAMEM6,=CL5'0080'                                J40B
         PUT   SYSIN,DATAMEM1
         PUT   SYSIN,(R10)
         AP    TOTRECOP,=P'1'
         LR    R9,R10
         CLC   0(2,R9),=H'80'
         BNH   OPRET
         LA    R10,80(R10)
         PUT   SYSIN,(R10)
         AP    TOTRECOP,=P'1'
         CLC   0(2,R9),=H'160'
         BNH   OPRET
         LA    R10,80(R10)
         PUT   SYSIN,(R10)
         CLC   0(2,R9),=H'240'
         BNH   OPRET
         LA    R10,80(R10)
         PUT   SYSIN,(R10)
         AP    TOTRECOP,=P'1'
OPRET    GENRETN
         LTORG
RECAREA  CSECT
RECORD   DS    CL80
RECORDX  DS    CL100
         ORG   RECORD
PCITYP   DS    CL2            CONTAINS 'I='
PCISTEP  DS    CL8            STEP NAME
PCISTMT  DS    CL4            STATEMENT NUMBER
PCILEV   DS    CL2            LEVEL NUMBER
PCINEST  DS    CL2            NEST
PCICMD   DS    CL8            COMMAND EG 'TYPE', 'IF', 'DO', 'END'
PCILEN   DS    CL4            LENGTH OF COMMAND OR BLANKS
PCITXT   DS    CL150          COMMAND TEXT
         ORG   RECORD
PCETYP   DS    CL5            CONTAINS 'ERUN '
PCESTMT  DS    CL4            STATEMENT NUMBER
PCEDUM1  DS    CL6            ' STEP='
PCESTEP  DS    CL8            STEP NAME
PCEDUM2  DS    CL5            ' PGM='
PCEPGM   DS    CL8            PROGRAM NAME
PCEDUM3  DS    CL10           ' PGMLABEL='
PCELABEL DS    CL8            LABEL
         ORG   RECORD
PCDTYP1  DS    CL3            CONTAINS 'DD '
PCDSTMT  DS    CL4            STATEMENT NUMBER
PCDDSID  DS    CL8            DSID NAME
PCDLEV   DS    CL2            LEVEL NUMBER
PCDNEST  DS    CL2            NEST
PCDTYP   DS    CL2            DDTYP
PCDDDNAM DS    CL8            DDNAME
PCDDISP1 DS    CL8            BIT PATTERN OF DDDISP(1)
PCDDISP2 DS    CL1            DDDISP(2)
PCDDISP3 DS    CL1            DDDISP(3)
* END OF PART 1 OF DD RECORD
         ORG   RECORD
PCDDSN1  DS    CL5            CONTAINS '*DSN='
PCDDSN   DS    CL44           CONTAINS DSNAME
PCDMEM1  DS    CL1            CONTAINS '(' MAYBE
PCDMEM   DS    CL8            CONTAINS MEMBER NAME
PCDMEM2  DS    CL1            CONTAINS ')' MAYBE
PCDPASS1 DS    CL1            CONTAINS '/' MAYBE
PCDPASSW DS    CL8            CONTAINS PASSWORD
* END OF PART 2 OF DD RECORD
         ORG   RECORD
PCDDCB1  DS    CL5            CONTAINS '*DCB='
PCDRECFM DS    CL5            DDRECFM
PCDBLKS  DS    CL8            DDBLKSZE
PCDLRECL DS    CL8            DDLRECL
PCDDENSX DS    CL2            DDDENS
PCDBUFNO DS    CL8            DDBUFNO
PCDOPTCD DS    CL4            DDOPTCD
PCDDSORG DS    CL4            DDDSORG
* END OF PART 3 OF DD RECORD
         ORG   RECORD
PCDUNIT1 DS    CL6            CONTAINS '*UNIT='
PCDUNIT2 DS    CL8            DDUNIT
PCDUNDUM DS    CL1            ',' IF UNIT NUMBER
PCDUNITC DS    CL2            DDUNITNO ('P' OR NUMBER)
* END OF PART 4 OF DD RECORD
         ORG   RECORD
PCDSPC1  DS    CL7            CONTAINS '*SPACE='
PCDSPCTY DS    CL1            DDCYLTRK  'T' 'C' OR 'B'
PCDRLSE  DS    CL1            ' ' OR 'R'
PCDPRIM  DS    CL8            DDPRIM
PCDSEC   DS    CL8            DDSEC
PCDDIR   DS    CL4            DDDIR
* END OF PART 5 OF DD RECORD
         ORG   RECORD
PCDVOL1  DS    CL5            CONTAINS '*VOL='
PCDFILE  DS    CL4            DDFILENO
*CDDENS  DS    CL2            DDDENS
PCDLABTY DS    CL2            DDLABTYP
PCDVOL   DS    CL44           DDVOL
* END OF PART 6 OF DD RECORD
         ORG
TOTRECOP DC    PL6'0'
#JOLPARM DC    AL2(ENDPARM-*)
JOLPARMC DC    C'JOL,INSTSIZE='
INSTSIZE DC    CL6'000000'
ENDPARM  EQU   *
*DWORKAR DS    CL256          USED IN DD WORK SET UP CSECT
BLANKS   DC    CL80' '
         PRINT NOGEN                                              J40B
CARDSIN  DCB   MACRF=GM,EODAD=EOCARDS,DDNAME=$$CARDS,DSORG=PS
SYSUT1   DCB   MACRF=GM,EODAD=EOJ,DDNAME=SYSUT1,DSORG=PS
SYSIN    DCB   LRECL=80,BLKSIZE=80,RECFM=F,MACRF=PM,DDNAME=SYSIN,      +
               DSORG=PS                                           J40B
DATAHD   DC    8X'FF'         THIS IS THE HEADER RECORD TO GO OUT
DATAHD2  DC    3C'JOL'         ON THE SYSIN FILE TO UJEINIT
DATAHD3  DC    8X'FF'
DATAHD4  DC    70X'00'
DATAHD5  DC    CL5' '
         SPACE
* THE 'DATAMEM' CARDS ARE CREATED FROM HERE AND ARE USED BY
*        THE UJEINIT PROGRAM TO CREATE THE PDS CONTAINING THE
*        USERS SYSIN CARD FILES AND THE JOL INSTRUCTIONS FOR
*        THE 'JOL' TRANSIENT SCHEDULER/INITIATOR.
* THE CARD BELOW TELLS UJEINIT A NEW MEMBER IS ABOUT TO START.
DATAMEM1 DC    8X'FF'         CHECKED BY 'UJEINIT' FOR VALIDITY
DATAMEM2 DC    CL15'JOLMEMSTART$$##'
DATAMEM  DC    CL8' '         MEMBER NAME TO BE USED IN THE 'STOW'
         DC    CL4'##$$'
DATAMEM4 DC    CL2'FB'        RECORD FORMAT FIELD FOR THE MEMBER
DATAMEM5 DC    CL5' '         BLOCKSIZE
DATAMEM6 DC    CL5' '         RECORD LENGTH
FILL0001 DC    C' '           FILLER ONLY
TOTCRDS  DC    F'0'           TOTAL NUMBER OF USER SYSIN CARDS
*                             AND SET UP IN UJP95 AND UJP96
           SPACE 2
* THIS IS A MINI VERSION OF THE DSECTS REQUIRED FOR MAINFRAME JOL.
*
* C. V. CLARKE, OCTOBER, 1988
*
* THERE ARE THREE DSECTS:
*
*     1. PGMDETS DESCRIBES THE INTERNAL MAINFRAME JOL REPRESENTATION
*        OF PROGRAM DETAILS REQUIRED FOR THE SCHEDULER TO LOAD
*        PROGRAMS.
*
*
*     2. DDDSNDETS DESCRIBES THE INTERNAL MAINFRAME JOL REPRESENTATION
*        OF DATA SET DETAILS REQUIRED FOR THE SCHEDULER TO PERFORM
*        WORK ON DATA SETS.
*
*        THE JOL MAINFRAME SCHEDULER CAN ALLOCATE DATA SETS DYNAMICALLY
*        CATALOG THEM ETC ETC.
*
*
*     3. INSTRUCTION DETAILS PRODIVE JOL WITH THE INFORMATION IT
*        NEEDS TO DO IF STATEMENTS, TYPE, DISPLAY ETC.
*
*
* PGMDETS
         COPY  PGMDETS                                            J40B
*
*
*
*
*$$$
         DS    0D                                                 J40B
         COPY  DDDSNDET                                           J40B
*
*
*
*
*
*
INST     CSECT
ILENGTH  DS    H             LENGTH OF RECORD
         DC    H'0'
II       DC    CL1'I'        SET TO 'E' FOR PGM EXEC
ILABEL   DS    CL8           PGM DECLARE LABEL OR PGM NAME
ISTMT    DS    CL4           STATEMENT NUMBER
ILEVEL   DS    CL1           LEVEL
INEST    DS    CL1
ICOMMAND DS    CL8           EG 'TYPE'
IBODY    EQU   *-ILENGTH     LENGTH OF BODY
ITEXT    DS    CL150         FIRST 2 BYTE ARE LENGTH
IDUMMY   DS    CL150
*
ILEN     EQU   *-ILENGTH
*
         END
*        COPY DDDSNDETS
************************************************************************
*
* IHADCB - I HAD A DCB DSECT FOR PC/370 RELEASE 2.0+ FILE DATA CONTROL B
*
************************************************************************
IHADCB   DSECT
DCBDCB   DS    CL4 CONSTANT EBCDIC C'ADCB' DCB IDENTIFIER
DCBDSN   DS    A   ADDRESS OF UP TO 64 BYTE PATH/FILE SPEC FOLLOWED BY Z
DCBFID   DS    H   FILE HANDLE ASSIGNED BY MS-DOS AT OPEN (X'FFFF'DEFAUL
DCBFLG   DS    X   DATA CONTROL BLOCK FLAGS (ONLY DFTRAN MAY BE SET BY U
DFOPEN   EQU   X'80' FILE OPEN
DFUBUF   EQU   X'40' USER DEFINED BLOCK AREA (NO DYNAMIC ALLOC/DEALLOC)
DFOUT    EQU   X'20' OPEN FOR OUTPUT
DFGEOF   EQU   X'10' END OF FILE PENDING ON SHORT BLOCK
DFTRAN   EQU   X'08' TRANSLATE GET/PUT RECORDS FOR ASCII FILE
DFADCB   EQU   X'01' ASSIST DCB - DO NOT TRANSLATE 370 ADDRESSES
DSORG    DS    C   DATA SET ORGANIZATION (R=RANDOM, S=SEQUENTIAL)
MACRF    DS    C   DATA SET ACCESS MODE (R=READ, W=WRITE, G=GET, P=PUT)
RECFM    DS    C   DATA SET RECORD FORMAT (F=FIXED, V=VAR, T=TEXT)
EOR      DS    X   END OF RECORD CODE (DEFAULT IS LINE FEED X'0A')
EOF      DS    X   END OF FILE CODE   (DEFAULT IS CTL-Z X'1A')
LRECL    DS    H   RECORD LENGTH (2<LRECL<64K-16)
BLKSZ    DS    H   BLOCK  LENGTH (2<BLKSZ<64K-16)
EODAD    DS    A   END OF DATA EXIT ADDRESS
SYNAD    DS    A   SYCHRONOUS ERROR EXIT ADDRESS
RCD      DS    A   RECORD AREA ADDRESS FOR GET/PUT
BLK      DS    A   BLOCK  AREA ADDRESS (0 FOR DYNAMICALLY ALLOCATED)
RBA      DS    A   RELATIVE BYTE ADDRESS FOR RANDOM READ/WRITE
REN      DS    A   RENAME ASCIIZ FILE (ONLY USED BY RENAME SVC)
IOCNT    DS    F   BLOCK I/O COUNT SINCE OPEN
PRECL    DS    H   PHYSICAL BLOCK SIZE OF LAST READ/WRITE
*
* RESERVED AREA FOR USE BY PC/370 IOS SUPERVISOR WHILE FILE OPEN
*
DSNSG    DS    XL4 SEGMENT:OFFSET OF DCBDSN PATH/FILE NAME
EODSG    DS    XL4 SEGMENT:OFFSET OF EODAD EXIT
SYNSG    DS    XL4 SEGMENT:OFFSET OF SYNAD EXIT
RCDSG    DS    XL4 SEGMENT:OFFSET OF RECORD AREA FOR GET/PUT
RENSG    DS    XL4 SEGMENT:OFFSET OF RENAME FILE NAME
BLKSG    DS    XL4 SEGMENT:OFFSET OF BLOCK AREA
BLKPTR   DS    XL4 SEGMENT:OFFSET OF CURRENT RECORD IN BLOCK AREA
BLKEOD   DS    XL2 OFFSET OF CURRENT END OF DATA IN BLOCK AREA
BLKEND   DS    XL2 OFFSET OF END OF ALLOCATED BLOCK AREA
WLRECL   DS    H   REVERSED LRECL
WBLKSZ   DS    H   REVERSED BLKSZ
LDCB     EQU   *-IHADCB
*
************************************************************************
         END  $JOLPC60
* DDDSNDETS
DDDSNDET CSECT
DDOSVB   DS    H             LENGTH OF RECORD
         DC    H'0'
DDDD1    DC    CL1'D'        SET TO 'D' FOR 'DD' CARD
DDDSID   DC    CL8' '        THE DATA SET IDENTIFIER
DDSTMT   DC    CL4' '        STMT NUMBER OF DECLARE
DDLEVEL  DC    AL1(0)        LEVEL OF THIS DECLARED DSID
DDNEST   DC    AL1(0)
DDTYPE   DC    AL1(0)        THIS FIELD CONTAINS INFO ABOUT THE DSID
DDDDNAME DC    CL8' '        DDNAME
DDDSNAME DC    CL44' '       DSNAME OR OTHER DETAILS
DDMBR    DC    CL8' '        MEMBER NAME ¦ GDG REL
DDPASSW  DC    CL8' '        PASSWORD FOR DATA SET
         ORG   DDDSNAME
DDSYSCLS DS    CL1           SYSOUT CLASS
DDSYSPGM DS    CL1           SYSOUT WRITER
DDSYSFRM DS    CL1           SYSOUT FORM NUMBER
DDCOPIES DS    AL1           COPIES
DDOUTLIM DS    AL3
DDUCS    DS    CL8
DDFCB    DS    CL8
DDROUTE  DS    CL8
DDALIGN  DS    AL1
DDVERIFY DS    AL1
DDFOLD   DS    CL1
         ORG   DDDSNAME
DDDSIDR  DS    CL8' '        CURRENTLY NOT USED
         ORG
DDUSE    DS    0AL1          SPECIAL INDICATORS FOR READ, WRITE ETC
DDDDISP  DC    CL3' '        SAME FIELD AS ABOVE
DDCANCEL DC    XL1'0'        SPECIAL BITS
DDADSID  DC    A(0)          ADDRESS (NOT CURRENTLY USED)
DDLABTYP DC    FL1(0)        SL, SUL ETC
DDVOLUME DC    CL44' '
         ORG   DDVOLUME
DDCHAR   DS    CL8           FOR 3380
DDFLASH  DS    CL8           FOR 3380
DDCHARS  DS    CL19          FOR 3380
DDMODIFY DS    CL8           FOR 3380
DDBURST  DS    CL1           FOR 3380
         ORG
DDLABEL  DC    H'0'          FOR TAPES
DDUNIT   DC    CL8' '        SYSDA, 3380 ETC
DDUNITNO DC    FL1'0'        NUMBER OF UNIT (OR 'P')
DDUNITYP DC    X'0'          SPECIAL INTERNAL UNIT INDICATORS
DDUNITQU DC    XL1'0'        SPECIAL INTERNAL UNIT INDICATORS
DDCATLGS DC    FL1'0'        CATALOG RETURN CODES
DDSPACE  EQU   *             START OF SPACE FIELDS
DDPRIM   DC    H'0'          PRIMARY SPACE FIELD
DDSEC    DC    H'0'          SECONDARY SPACE FIELD
DDDIRECT DC    H'0'          DIRECTORY BLOCKS
DDCYLTRK DC    CL1' '        'C', 'T' ETC
DDSPECTP DC    XL1'0'        'PRIVATE' INDICATORS ETC
DDSPECT2 DC    XL1'0'        'VSAM' INDICATORS ETC
DDDCB    EQU   *             START OF DCB FIELDS
DDRECFM  DC    CL4' '        'VB' 'FB'
DDBLKSZE DC    H'0'          BLOCKSIZE
DDLRECL  DC    H'0'          LRECL
DDSIZE   DC    H'0'
DDSIZE2  DC    H'0'
DDAVREC  DC    H'0'          AVERAGE RECORD SIZE
DDSIZEQ  DC    CL1' '        USED FOR DDAVREC BELOW
DDBUFNO  DC    FL1'0'
DDBUFL   DC    H'0'
DDBUFNI  DC    FL1'0'
DDBUFND  DC    FL1'0'
DDLIMCT  DC    CL1' '
DDOPTCD  DC    CL6' '
DDDENS   DC    AL1(0)
DDRKP    DC    FL1'0'
DDKEYLEN DC    FL1'0'
DDOVERFL DC    FL1'0'
DDDSORG  DC    CL3' '
DDRETPD  DC    CL1' '
DDEXPTD  DC    CL5' '
DDVOLSEQ DC    FL1'0'
DDMAXVOL DC    FL1'0'
DDCODE   DC    CL1' '
DDFUNC   DC    CL1' '
*
DDLEN    EQU   *-DDOSVB
DDEXTRA  DC    CL29' '
PGMDETS  CSECT
#PGMDETS DS    H             LENGTH OF RECORD
         DC    H'0'
PGMTYPE1 DC    CL1'E'        SET TO 'E' FOR PGM EXEC
PGMLABEL DC    CL8' '        PGM DECLARE LABEL OR PGM NAME
PGMSTEP  DC    CL8' '        STEP NAME OUTPUT (FROM RUN LABEL)
PGMADDR  DC    CL4' '        'VIRT' OR 'REAL'
PGMSTMT  DC    CL4' '        PGM DECLARE STMT NUMBER
PGMLEVEL DC    CL1' '        PGM DECLARE LEVEL (MACROS)
PGMNEST  DC    CL1' '
PGMID    DC    CL8' '        DECLARE IDENTIFIER
PGM      DC    CL8' '        MODULE NAME TO BE EXECUTED
PGMSIZE  DC    CL5' '
PGMSIZEQ DC    CL1' '
PGMTIME1 DC    CL4' '
PGMTIME2 DC    CL4' '
PGMTIMEQ DC    CL1' '
PGMESTMT DC    CL4' '        EXEC STMT NUMBER
PGMACCT  DC    CL8' '
PGMPERFO DC    H'0'          PERFORMANCE GROUP
PGMNODYN DC    H'0'          DYNAMIC DD
PGMNODDS DC    H'0'          NUMBER OF DD CARDS WITH THIS PROGRAM
*
PGMLEN   EQU   *-PGMDETS
//LKED    EXEC PGM=IEWL,PARM='TEST,XREF,LIST,LET',REGION=512K
//JOL60OBJ  DD DSN=CLARKE.JOL60.OBJ,DISP=SHR
//SYSLIB    DD DSN=CLARKE.JOL60.OBJ,DISP=SHR
//SYSLMOD   DD DSN=CLARKE.JOL60.LOAD,DISP=SHR
//SYSUT1    DD DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(CYL,(2,2))
//SYSPRINT  DD SYSOUT=*
//SYSLIN    DD *
  INCLUDE JOL60OBJ($JOLPC60)
  NAME  $JOLPC60(R)
//E EXEC  PGM=XJOLPC40
//STEPLIB   DD DSN=CLARKE.JOL60.LOAD,DISP=SHR
* INCLUDE JOL35LOD(ALL3)
//*YSUT2   DD  DSN=&&SYSUT2,SPACE=(CYL,(2,2)),UNIT=SYSDA
//SYSIN    DD  SYSOUT=X,SPACE=(CYL,(2,2)),UNIT=SYSDA
//SYSPRINT DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//JOLPRINT DD  SYSOUT=*,DCB=(RECFM=VBA,LRECL=200,BLKSIZE=1330),
// OUTLIM=1000                                                   J40B
//SYSUT1   DD  DSN=CLARKE.JOL60B.ASM(JOLPCTST),DISP=SHR
//$$CARDS  DD  DSN=CLARKE.JOL60B.ASM(JOLPCCRD),DISP=SHR
