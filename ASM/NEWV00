         COPY   JOLCOM
V00DSECT DSECT
V00LSTEP DS    CL8       LAST USED STEP NAME OF DATA SET
V00LDDNM DS    CL8       LAST USED DDNAME OF DATA SET IN ABOVE STEP
V00LEVEL DS    CL1       ORIGINAL LEVEL DATA SET USED AT
V00NEST  DS    CL1       ORIGINAL NEST  DATA SET USED AT
V00FREE  DS    CL1       THIS BLOCK (OR RECORD) IN THE TABLE IS
*                        NOW FREE, AND MAY BE RE-USED FOR NEW DSN'S
V00REC1  DS    H         RECORD NUMBER OF LAST USE OF DATA SET (OR 0)
V00OLDNM DS    CL44      DECLARED DSNAME
V00NEWNM DS    CL44      DSNAME AFTER CATALOG SEARCHING ETC
V00VOLS   DS    CL(L'DDVOLUME) VOLUMES
V00UNIT  DS    CL8       UNIT
V00JOLUN DS    CL1       UNIT TYPE (JOL INTERNAL CODE)
V00DISP1 DS    CL1       IF A DISPOSITION INSTRUCTION IS FIRST,
*                        THIS WILL CONTAIN %  (CHANGED WHEN FIRST
*                        NON-DISP INSTRUCTION FOUND)
V00DLEN  EQU (((*-V00DSECT+1)/2)*2)
V00SAVE  DSECT
         DS    18F
V00NODSN DS    H
V00REC   DS    H
V00STRTB DS    A              BXLE CONSTANTS FOR SEARCHING
V00TBLIN DS    A              * TABLE SAVED
V00TBLEN DS    A              *   HERE
V00CLEV  DS    CL1            CURRENT LEVEL NUMBER
V00STRTS  DS    A             LOOP VARIABLES
          DS    A
          DS    A
V00SAVEN EQU   *
         JOLSAVE CSECT=UJV00MN,SIZE=(V00SAVEN-V00SAVE)
* IN PREVIOUS VERSIONS OF JOL, THE ENTIRE JOB WAS READ INTO
*  CORE STORAGE AND CATALOG SEARCHES, VALIDATION ETC PERFORMED
*  BY SCANNING OVER THE JOB.
* THIS REQUIRED A LARGE TABLE (IN THE ORDER OF 60K) FOR A MODERATE
*  SIZED JOB TO BE GENERATED, AND THEREFORE JOL NEEDED ABOUT 100K
*  TO EXECUTE IN.
* IN THIS (AND SUBSEQUENT VERSIONS), A PAGING SYSTEM IS USED.
* THIS WILL ALLOW JOL TO RUN IN ABOUT 40K OF MAIN STORAGE AND
* (BELIEVE IT OR NOT) EXECUTE CONSIDERABLY FASTER THAN IT
* USED TO UP TO VERSION 2.6
         SPACE
* TO ANALYSE THE JOB PROPERLY,AND PASS DATA SETS ETC, WE NEED
*  TO DO THE FOLLOWING:-
*
*        1. PASS ANY DATA SETS FROM ONE STEP TO ANOTHER IF THEY
*              ARE REFERENGED IN A LATER JOB STEP
*        2. WORK OUT WHICH ARE TEMPORARY FILES, AND WHICH ARE
*              MERELY WORK FILES
*        3. WHICH ARE INPUT DATA SETS THAT WE HAVE TO SEARCH THE
*              SYSTEM CATALOG FOR
*        4. WHICH DATA SETS NEED TO BE VOL-REFED BACK TO AN EARLIER
*              DD STMT IN THE SAME STEP (EG TWO TEMPORARY DATA SETS)
*
* WE DO KNOW THE FOLLOWING:-
*
*        1. THE FILE THAT WE SHALL BE READING BACK AND FORTH
*              CONTAINS 'EXEC' RECORDS AND 'DD' RECORDS.
*        2. EACH 'DD' RECORD IS:-
*              A) A REAL DD-CARD WITH A REAL DSNAME
*              B) A DD-CARD WITH A DSN OF &&TEMPNNNN
*                   WE HAVE TO WORK OUT WHETHER TO MAKE IT A
*                   WORK FILE, OR PASS IT
*              C) SYSOUT, SYSIN TYPES OF DATA SETS
*
* THIS IS GOING TO TAKE AT LEAST 2 PASSES, DEPENDING ON THE SIZE
*  OF THE JOB SUBMITTED.
         SPACE 3
* BASICALLY, THE CODE GOES LIKE THIS:-
*        READ A RECORD
*        IF EXEC, CHANGE STMT NUMBERS FOR ERROR MSSGS, OP, BACK TO READ
*        IF OPCNTL BEFORE JOBCARD, COLLECT IT IN A TABLE
*        IFÂ¬DD, O/P
*        IF DD, CHECK IF DSNAME IN TABLE.
*        IF NOT, ENTER IT, SEARCH CATLG ETC AS NEC
*        IF SO, MARK DATA SET AS BEING USED LATER ON (PASS)
*
* THEN RE-READ THE FILE AND CREATE THE JCL.....
*
* NOW WE NEED SOME STORAGE FOR THE TABLE
*        CONTAINING THE DSNAMES ETC
*
         L     R0,=A(100*(V00DLEN))     ALLOW SPACE FOR 100 DATA SETS
         ST    R0,LGOTTEN               STORE ADDRESS OF GOTTEN STORAGE
         GETMAIN R,LV=(0)
         ST    R1,AGOTTEN
         USING V00SAVE,R13
         ST    R1,V00STRTS
         ST    R1,V00TBLEN
         CLEAR V00NODSN,V00REC
         MVC   V00TBLIN,=A(V00DLEN)
*
* NOW WE SET TO AND READ THE 'INST' FILE
*
         SPACE
*
*        LETS PRIME THE BUFFER SPACE, UNLESS THERE ARE NO RECORDS
*
         CLC   INSTTTR1,ZERO
         BNE   V00ARERC       THERE ARE RECORDS
         JOLERR 401           NO TEXT MESSAGE
         JOLRETN RC=16        AND BAD RETURN CODE
         SPACE 3
V00ARERC EQU   *
         LH    R0,LINSTBUF    LOAD LENGTH OF BUFFER
         GETMAIN R,LV=(0)
         ST    R1,AINSTBUF    STORE ADDRESS OF AREA OBTAINED
         MVC   0(6,R1),=AL2(4,0,300) SET BUFFER SO NEXT GET RECORD
*                             WILL HAVE TO READ A BLOCK
         MVC   INSTLAST,=H'350'
         MVC   INSTBLKN,ZERO
         SPACE 3
* NOW DOWN TO SERIOUS BUSINESS
         SPACE 3
         LA    R5,#WORK       ANY 'EXEC' CARDS WILL BE MOVED HERE
         USING PGMDETS,R5
         USING DDDSNDET,R4
*
V00READ  BAL   R12,V00GETRC
* V00GETRC RETURNS THE ADDRESS OF THE RECORD IN R4, AND R15=4
*        IF EOF FOUND
* NOTE ****
* WHEN THE END OF A BLOCK IS FOUND, THE BLOCK WILL BE RE-WRITTEN,
*  AS THE CONTENTS OF THE BLOCK WILL HAVE CHANGED.
*
*
         LTR   R15,R15        EOF ?
         BNZ   V00EOF1        YES
         CLI   DDDD1,C'D'     DD ENTRY?
         BE    V00DD          YES, GO DEAL WITH IT.
         CLI   DDDD1,C'E'     EXEC STMT ?
         BNE   V00TMAC        NO -> TEST MACRO START/END
         MVC   #WORK(PGMLEN),PGMDETS-PGMDETS(R4)  SAVE PGM DETS
         MVC   STMT,PGMESTMT  SAVE EXEC STMT # FOR ERROR MESSAGES
         B     V00READ
         SPACE 3
V00TMAC  CLI   DDDD1,C'I'     INSTRUCTION
         BNE   V00READ        NO -> IGNORE IT
         CLC   =C'MACRO ',ICOMMAND-INST(R4)  MACRO START ?
         BNE   V00TEND
         MVC   V00CLEV,ILEVEL-INST(R4)  CHANGE LEVELS
         B     V00READ                  BACK TO READ
         SPACE 3
V00TEND  CLC   =C'END ',ICOMMAND-INST(R4) END ?
         BNE   V00READ                  NOPE ->
         CLC   V00CLEV,ILEVEL-ICOMMAND(R4)
         BNH   V00READ
         SPACE 2
* OK FOLKS, HERE WE HAVE REACHED A MACRO END.
*  THE TABLE WE ARE FORMING UP WILL HOLD A HUNDRED DSN'S
*   SO WE WANT TO GET RID OF ANY WORK FILE NAMES
*  IF WE DIDN'T, 20 SORTS WOULD OVERFLOW IT
         SPACE 2
         MVC   V00CLEV,ILEVEL-ICOMMAND(R4)
         LM    R7,R9,V00STRTS      LOAD BXLE VARIABLES FOR TABLE SEARCH
         USING V00DSECT,R7
V00BXLE1 BXLE  R7,R8,V00TDELD
         B     V00READ
V00TDELD CLC   V00CLEV,V00LEVEL    IS DS LEVEL > CURRENT LEVEL
         BNL   V00BXLE1            NO
         CLC   V00REC1,ZERO        IS DATA SET REQUIRED LATER ?
         BNE   V00BXLE1
         CLC   =C'&&&&TEMP',V00OLDNM    TEMPORARY DSN ?
         BNE   V00BXLE1                 NOPE ->
* HERE WE HAVE A NON-PASSED TEMPORARY DATA SET.
*  WE SHALL NOW DELETE IT FROM THE TABLE (THEN NEXT PASS KNOWS
*  IT IS ONLY A WORK FILE)
         MVI   V00FREE,C'1'             MARK RECORD RE-USABLE
         B     V00BXLE1
         SPACE 3
         EJECT
V00DD    EQU   *
         CLI   DDDSNAME,C'*'  SYSIN ?
         BE    V00READ        YES -> IGNORE IT
         CLC   =C'SYSOUT=',DDDSNAME  SYSOUT ?
         BE    V00READ        YES -> IGNORE IT
         CLI   DDDSNAME,C'%'  NO DSN CODED ?
         BE    V00READ        YES -> IGNORE IT
* HERE TIS A REAL DSNAME
         LM    R7,R9,V00STRTS LOAD BXLE VARIABLES FOR TABLE SEARCH
V00BXLEZ BXLE  R7,R8,V00FNDSN
* HERE THE DSNAME IS NOT IN THE TABLE
V00MAKEN EQU   *
         LM    R7,R9,V00STRTS      PREPARE TO SEARCH TABLE AGAIN
V00BXLE3 BXLE  R7,R8,V00FINDS
         L     R15,AGOTTEN         DIDN'T FIND A FREE ENTRY IN TABLE -
         A     R15,LGOTTEN         SO WE HAVE TO ADD TO THE END
         CR    R7,R15              TEST IF ANY MORE RECORDS WILL FIT
         BL    V00WILLF            YES
         JOLERR 402,'DSNAME TABLE IS FULL'
         FREEMAIN
         JOLRETN RC=16
V00WILLF ST    R7,V00TBLEN         RESET END TABLE INDICATOR
         B     V00NEWDS
V00FINDS CLI   V00FREE,C' '        IS THIS ENTRY FREE ?
         BNE   V00BXLE3            NO,LOOK FOR NEXT
V00NEWDS EQU   *                   YES WE HAVE A FREE ENTRY, OR WE -
*                                  HAVE ADDED A NEW ENTRY ON THE END
* STORE NEW DSNAME IS TABLE
         MVC   V00OLDNM,DDDSNAME        ORIGINAL DSNAME
         MVC   V00UNIT,DDUNIT           UNIT
         MVC   V00JOLUN,DDUNITYP        UNIT TYPE (JOLS)
         MVC   V00LEVEL,DDLEVEL         LEVEL
         MVC   V00NEST,DDNEST           NEST
         MVC   V00LSTEP+2(4),PGMESTMT   STEP NAME
         OC    V00LSTEP(8),=C'$$0000  ' STEP NAME
         MVI   V00FREE,C' '             TURN OFF FREE INDICATOR
         MVC   V00REC1,ZERO             PASS INDICATOR = 0
         MVI   V00DISP1,C' '            BLANK DISP INDICATOR TEMPORARIL
         CLI   DDDDNAME,C'%'            DISPOSITION INSTRUCTION ?
         BNE   V00DISPL
         CLI   DDDDNAME+1,C'S'          SCRATCH ?
         BE    V00DISPS                 YES, MAKE %
         CLI   DDDDNAME+1,C'D'     DELETE ?
         BE    V00DISPS
         CLI   DDDDNAME+1,C'U'     UNCATLG ?
         BNE   V00DISPL
V00DISPS MVI   V00DISP1,C'%'       TURN ON DISP INDICATOR
V00DISPL EQU   *
* NOW WE MAY HAVE TO SEARCH THE CATALOG
         CLI   DDMBR,C'('     GDG ?
         BE    V00SRCH        YES -> GO SEARCH ALWAYS
         TM    DDUSE,B'11000000' NEW | MODS?
         BM    V00NEW1        YES, DON'T SEARCH THE CATALOG
         CLI   DDVOLUME,C'*'  VOLREF ?
         BE    V00VREF1       DON'T SEARCH EITHER, BUT GO DOWN TABLE
*                             TO SEE IF WE CAN PICK UP A REAL VOLUME
         CLI   DDVOLUME,C' '  VOL BLANK ?
         BE    V00SRCH        YES, AND OLD,SO SEARCH
         CLI   DDUNIT,C' '    UNIT CODED ?
         BNE   V00NEW1        NO, SO SEARCH
         CLI   DDUNITYP,C' ' JOL UNIT CODED? (PREFERRED VOL?)
         BNE   V00NEW1
V00SRCH $CALL  UJS01CAT,DDDSNDET   SEARCH CATALOG THEN
         MVC   V00VOLS,DDVOLUME     SAVE VOLUME RETURNED
         MVC   V00UNIT,DDUNIT      AND UNIT
         MVC   V00JOLUN,DDUNITYP   AND UNIT TYPE (JOL INTNL CODE)
         MVC   V00NEWNM,DDDSNAME   AND THE DSNAME (MAY HAVE BEEN
*                                  CHANGED BECAUSE T'WAS A GDG, OR
*                                  INITIATOR DEDICATED DATA SET)
         B     V00NEW1             GO CHECK A BIT MORE
         SPACE 3
V00VREF1 LR    R1,R7               SAVE POINTER TO NAME
         LM    R7,R9,V00STRTS
V00BXLE4 BXLE  R7,R8,V00FVRF2
         B     V00READ        COULDN'T FIND VOLREF DSN, ERROR ? *******
V00FVRF2 CLC   V00OLDNM(43),DDVOLUME+1
         BNE   V00BXLE4
         CLI   V00VOLS,C'*'    VREF ITSELF ?
         BE    V00READ
         MVC   V00VOLS-V00DSECT(R1),V00VOLS CHANGE VOL NAME
         B     V00READ
         SPACE 3
V00NEW1  EQU   *
* NOW BOTH THE DDUNITYP & DDUNIT FIELDS SHOULD BE SET UP IF POSSIBLE
* IF THE CATALOG SEARCH ROUTINE FOUND THE VOLUME, BOTH WOULD BE
* SET UP, BUT IF THE USER CODED A PREFERRED VOLUME, OR A UNIT
* TYPE, ONE OR TOTHER WOULD (MAY) NOT BE SET UP.
         TM    DDUSE,1        UNIT-AFF ?
         BO    V00LEAVE       IGNORE THIS SECTION
* OK, THINK WE HAVE TO GO SEARCHING THE 'JOLGEN' UNIT TABLES
         L     R1,AJOLGEN     LOAD ADDRESS OF 'JOLGEN' DETAILS
         L     R1,AGENUNIT     LOAD UNIT TABLE ADDRESS
         LR    R15,R7         SAVE POSITION IN TABLE:WE WILL USE R7 NOW
         LM    R7,R9,0(R1)    LOAD TABLE ADDRESSES FOR BXLE
         CLI   DDUNITYP,C' '  IS JOL INTERNAL UNIT TYPE SET UP YET ?
         BNE   V00FIXUN       YES, ->
* HERE THE DDUNIT FIELD IS NOT BLANK, BUT THE DDUNITYP FIELD IS,SO FIX
V00FUN9  CLC   DDUNIT,0(R7)   IS USER CODED UNIT IN TABLE
         BE    V00GOTUN       YES
         BXLE  R7,R8,V00FUN9  TRY NEXT ENTRY IN TABLE
         JOLERR 203,'UNIT ''',DDUNIT,''' IS NOT KNOWN TO JOL'
         B     V00NEWEN
V00GOTUN MVC   DDUNITYP,10(R7) SHIFT IN INTERNAL CODE
         LR    R7,R15          AND RELOAD TABLE ENTRY ADDRESS
         MVC   V00JOLUN,DDUNITYP PUT JOL UNIT TYPE IN TABLE AS WELL
         B     V00NEWEN
         SPACE 3
V00FIXUN EQU   *
* HERE THE DDUNITYP FIELD IS NOT BLANK, BUT THE UNIT IS, SO PUT IN A
*  PROPER UNIT
         LA    R1,X'FF'-B'01100000' DROP PERM BITS ETC
         IC    R14,DDUNITYP        LOAD DDUNIT TYPE
         NR    R14,R1              DROP PERM BITS
         STC   R14,DBL             STORE TEMPORARILY
V00FTYP3 CLC   DBL(1),16(R7)       IS IT IN TABLE ?
         BE    V00GOTYP            YEP ->
         BXLE  R7,R8,V00FTYP3      TRY NEXT ENTRY
         JOLERR 404,'PREFERRED VOLUMES ''',DDVOLUME,''' HAVE UNKNOWN UN*
               IT TYPE'
         B     V00NEWEN
V00GOTYP MVC   DDUNIT,8(R7)        OK, PUT IN UNIT TYPE
         LR    R7,R15              RELOAD R7 TO -> V00DSECT TABLE ENTRY
         MVC   V00UNIT,DDUNIT      SHIFT UNIT IN THERE ALSO
         B     V00NEWEN
V00NEWEN B     V00READ             GET NEXT RECORD FROM FILE
         SPACE 3
V00FNDSN CLC   DDDSNAME,V00OLDNM   IS THE DSNAME ALREADY IN TABLE ?
         BNE   V00BXLEZ            NOT THIS ENTRY ANYWAY, GO TRY NEXT
* HERE THE DSNAME IS ALREADY IN THE TABLE.
* IF THE DSNAME IN THE TABLE WAS PLACED THERE BECAUSE OF A
*  DISPOSITION INSTRUCTION, AND THIS IS NOT A DISPOSITION INSTRUCTION,
*  WE WILL IGNORE THIS ENTRY, AND START ALL OVER
* THIS IS BECAUSE SOMEONE MAY HAVE SAID SCRATCH A DATA SET,
*  AND THIS DD CARD HERE WANTS TO RE-CREATE IT.
*** NOTE: IF THIS IS A NEW DD ENTRY (OUTPUT), AND THE ONE EARLIER
* IS A SCRATCH, ALL IS WELL, OTHERWISE WE'LL GIVE AN ERROR AND MAKE
*  IT 'RECREATES'
         CLI   DDDDNAME,C'%'  IS THIS ENTRY A DISPOSITION ?
         BE    V00OLDOK
* OK,IF THE ONE IN THE TABLE IS A DISP, OVER-WRITE IT
         CLI   V00DISP1,C'%'
         BNE   V00OLDOK
         MVI   V00FREE,C'1'        MARK ENTRY AS 'FREE'
         B     V00MAKEN            MAKE A NEW ENTRY
         SPACE 3
V00OLDOK EQU   *
* NOW TEST IF THIS IS NEW, AND IF SO GIVE AN ERROR MSSG
         TM    DDUSE,X'40'    NEW ?
         BZ    V00OLD
         TM    DDUSE,X'80'    RE-CREATES (USES)
         BO    V00OLD
         JOLERR 205,'DSID ''',DDDSID,''' DSNAME ''',DDDSNAME,          *
               ''' DECLARED AT ',DDSTMT,' IS ALSO OUTPUT EARLIER:- NOW *
               ''USES'''
         MVI   DDUSE,X'C0'    USES
         MVC   DDDSNAME,V00NEWNM   CHANGE DSN'S (MAY HAVE BEEN A GDG)
         MVC   V00REC1,V00REC      MOVE IN 'PASS' RECORD NUMBER
V00OLD   IFVALUE DDVOLUME,V00LVOL1
         MVC   DDVOLUME,V00VOLSS
V00LVOL1 IFVALUE DDUNIT,V00LUNIT
         MVC   DDUNIT,V00UNIT
         MVC   DDUNITYP,V00JOLUN
V00LUNIT EQU   *
* NOW WE ARE NOT QUITE FINISHED YET.
*  IF THIS DSNAME HAS NO VOLUME, OR IS A VREF, AND IT IS THE SECOND
* SUCH REFERENCE IN THE SAME OS STEP,WE HAVE TO MAKE A VREF TO THE
* DDNAME
         CLI   DDVOLUME,C' '  VOL ''
         BE    V00CHKRF       YES, CHECK IF USED ALREADY THIS STEP
         CLI   DDVOLUME,C'*'       VREF ?
         BNE   V00CHNGR            NO, CHANGE LATEST STEP NUMBER THOUGH
V00CHKRF EQU   *
         CLC   V00LSTEP+1(4),PGMESTMT ALREADY USED IN THIS STEP ?
         BNE   V00CHNGR            NO
* SET UP VREF TO DDNAME THEN
         CLEAR DDVOLUME
         MVC   DDVOLUME(3),=C'**.' VREF INDICATOR
         MVC   DDVOLUME+3(8),V00LSTEP
         MVI   DDVOLUME+12,C'.'
         MVC   DDVOLUME+13(8),V00LDDNM
         NI    DDDISP,1       MAKE SHR (OLD)
         B     V00READ
V00CHNGR MVC   V00LSTEP+1(4),PGMESTMT
         OC    V00LSTEP+1(4),=C'0000'
         MVC   V00LDDNM,DDDDNAME
         B     V00READ
         TITLE ' PASS2, FIX PASS INDICS ETC'
V00EOF1  EQU   *
         BAL   R12,V00PRIM    PRIME THE BUFFERS
V00READ2 BAL   R12,V00GETRC   READ A RECORD
         LTR   R15,R15
         BNZ   V00EOF2        2ND EOF, END PASS 2, RETURN
         CLI   DDDD1,C'E'     EXEC RECORD ?
         BNE   V00NEXE2       NOPE
         MVC   #WORK(PGMLEN),PGMDETS-PGMDETS(R4)  SAVE PGM DETS
         MVC   STMT,PGMESTMT
         ZAP   WORKDS,=P'0'   RESET &&UT NUMBER
         B     V00READ2
V00NEXE2 CLI   DDDD1,C'D'     DD ENTRY OR RECORD ?
         BE    V00DD2         YES, GO FIX
         CLI   DDDD1,C'I'     INSTRUCTION ?
         BNE   V00READ2       NOPE -> IGNORE IT FOR NOW
         CLC   ICOMMAND-INST(,R4),=CL8'OPCNTA' OPCNTL AFTER JOBCARD ?
         L     R1,ACNTNLA     LOAD A TABLE FOR OP AFTER
         LH    R14,0(R1)      LOAD CURRENT NUMBER OF CARDS THERE
         LA    R14,1(R14)     ADD 1
         CH    R14,2(R1)      TOO MANY ?
         BL    V00AFTOK
         JOLERR 206,'TOO MANY OPCNTL CARDS'
         B     V00READ        IGNORE IT
V00AFTOK EQU   *
         STH   R14,0(R1)      RESET # OPCNTLA
         MH    R14,=H'80'     MULT * 80
         AR    R14,R1         POINT TO AVAILABLE HOLE
         MVC   0(80,R14),IBODY-INST(R4) SHIFT CARD IN
         B     V00READ2       BACK FOR NEXT RECORD
V00DD2   EQU   *
         LM    R7,R9,V00STRTB      LOAD TABLE BXLE VARIABLES
V00BXLES BXLE  R7,R8,V00FDS2
* HERE THE DSNAME WAS NOT FOUND.
*  IT SHOULD ONLY BE A TEMPORARY DATA SET.
         CLC   =C'&&&&TEMP',DDDSNAME
         BE    V00MAKUT
         JOLERR 407,'INTERNAL ERROR,DSN ''',DDDSNAME,''' MISSING'
         B     V00READ2
V00MAKUT EQU   *
* HERE WE MAKE THE DSNAME &UTN WHERE N GOES FOR 1 TO 9, OR  9-99
         AP    WORKDS,=P'1'   ADD 1 TO CURRENT NUMBER
         CLEAR DDDSNAME            CLEAR DSNAME
         MVC   DDDSNAME(3),=C'&&UT' MAKE '&UT'
         CP    WORKDS,=P'9'
         BH    V00UTBIG
         UNPK  DDDSNAME+3(1),WORKDS
         OI    DDDSNAME+3,C'0'
V00WKDEL MVI   DDDISP+1,C'D'       MAKE 'DELETE'
         B     V00READ2
V00UTBIG UNPK  DDDSNAME+3(2),WORKDS
         OI    DDDSNAME+4,C'0'
         B     V00WKDEL
V00FDS2  CLC   DDDSNAME,V00NEWNM
         BNE   V00BXLE5
* HERE WE HAVE A DSNAME.
* WHAT WE HAVE TO DO NOW IS WORK OUT WHERE TO PASS IT TO.
         CLC   V00REC1,V00REC
         BH    V00PASS
* DATA SET NOT REQUIRED LATER, MARK 'L'
         MVI   DDDISP+1,C'L'
         B     V00READ2
V00PASS  MVI   DDDISP+1,C'P'
         B     V00READ2
V00GETRC EQU   *
* THIS SUBROUTINE IS CALLED WHEN WE WANT A NEW RECORD
* ON RETURN, R15=4 IF NO RECORDS LEFT,  OR
*        R15=0 AND R4 POINTS TO THE RECORD FOUND
*** NOTE ***  IF A NEW BLOCK IS REQD, THE CURRENT ONE IS
*        RE-WRITTEN (LOS INFORMATION WILL HAVE BEEN CHANGED IN
*        THE BLOCK)
         SPACE 3
* INSTLAST CONTAINS THE CURRENT OFFSET OF THE CURRENT RECORD
*        SO WE CAN EASILY CALCULATE WHERE THE NEXT RECORD IS TO
*        START BY ADDING THE OFFSET + THE LENGTH OF THE CURRENT
*        RECORD.
         L     R1,AINSTBUF    LOAD ADDRESS OF THE BUFFER
         LH    R15,INSTLAST   LOAD OFFSET TO CURRENT RECORD
         AH    R15,0(R1,R15)  ADD OFFSET + CURRENT RECORD LENGTH
         B     *+4
         B     *+4
         CH    R15,0(R1)      WILL THIS RUN OVER BLOCK LENGTH
         BL    V00SETR4       NOPE
* NOW HERE WE HAVE TO WRITE THE CURRENT BLOCK AND RESET THE TTR
*        IN THE CONTROL SECTION
         MVI   SYS1NEXT+3,1   POINT TO BLOCK PAST LAST
         L     R15,AWORKFIL   LOAD A(DCB) WORKFILE
         POINT (R15),SYS1NEXT POINT TO NEXT AVAILABLE TTR
         L     R1,AINSTBUF
         WRITE WORKDECB,SF,,(1),MF=E    RE-WRITE THE BLOCK
         CHECK WORKDECB       CHECK ALL IS WELL
         L     R1,AWORKFIL    RELOAD DCB ADDRESS
         NOTE  (R1)           NOTE WHERE THE BLOCK WENT TO
         ST    R1,SYS1NEXT    STORE TTR -
         MVI   SYS1NEXT+3,1   * +1 FOR NEXT OP
         LH    R14,INSTBLKN   LOAD CURRENT BLOCK NUMBER COUNTER
         LR    R15,R14        SAVE IT
         SLL   R14,2
         ST    R1,INSTTTR1-4(R14)  RESET NEW TTR NUMBER
* CHECK IF MORE BLOCKS ON DATA SET
         LA    R15,1(R15)     SEE NEXT BLOCK-NUMBER
         CH    R15,INSTMAXB   > MAXIMUM
         BH    V00REOF        YES, EOF EFFECTIVELY
         STH   R15,INSTBLKN   RESET CURRENT BLOCK NUMBER
         SLL   R15,2          * 4
         LA    R15,INSTTTR1-4(R15)
         CLC   0(R15),ZERO    MORE BLOCKS ?
         BE    V00REOF        NO, EOF EFFECTIVELY
         L     R14,AWORKFIL   LOAD DCB ADDRESS
         POINT (R14),(R15)    POINT TO REQUIRED BLOCK
         L     R15,AINSTBUF   LOAD BUFFER ADDRESS
         READ  WORKINDB,SF,,(R15),MF=E
         CHECK WORKINDB
         CLEAR INSTLAST
         B     V00GETRC
V00SETR4 STH   R15,INSTLAST
         LA    R4,0(R15,R1)   SET  R4= A(BUFFER) + OFFSET
         B     *+4
         SR    R15,R15        SET  RETURN CODE
         BR    R12            RETURN TO CALLER
V00REOF  SR    R4,R4          CLEAR R4
         LA    R15,4          SET 15=4
         BR    R12            RETURN
         END
